#!/bin/bash

# Code Box - Universal AI Coding Sandbox
# https://github.com/nezhazheng/code-box

set -e

# Version - auto-generated from last modified date
# Format: YYYY.MM.DD (updated automatically when script changes)
VERSION="2025.01.09"

# Color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configuration
IMAGE_NAME="nezhazheng/code-box:latest"
CONFIG_DIR="${HOME}/.code-box"
PORTS_FILE="${CONFIG_DIR}/ports.json"
CLAUDE_CONFIG_DIR="${HOME}/.claude"
LAST_UPDATE_CHECK_FILE="${CONFIG_DIR}/.last_update_check"
UPDATE_CHECK_INTERVAL=86400  # 24 hours in seconds

# Update URLs
REPO_RAW_URL="https://raw.githubusercontent.com/nezhazheng/code-box/main"
SCRIPT_URL="${REPO_RAW_URL}/code-box"

# Resource limits
MEMORY_LIMIT="4g"
CPU_LIMIT="2"
SHM_SIZE="2g"

# Port range for random allocation
PORT_MIN=10000
PORT_MAX=60000

# Ensure config directory exists
mkdir -p "${CONFIG_DIR}"

# Get hash of current script
get_local_hash() {
    local script_path=$(which code-box 2>/dev/null || echo "${HOME}/.local/bin/code-box")
    if [ -f "$script_path" ]; then
        # Use md5 on macOS, md5sum on Linux
        if command -v md5 &>/dev/null; then
            md5 -q "$script_path" 2>/dev/null || echo ""
        else
            md5sum "$script_path" 2>/dev/null | cut -d' ' -f1 || echo ""
        fi
    fi
}

# Auto-update check function
check_for_updates() {
    # Skip update check for certain commands
    case "${1:-}" in
        --help|-h|--version|-v|--update)
            return 0
            ;;
    esac

    # Check if we should skip update check (based on last check time)
    if [ -f "${LAST_UPDATE_CHECK_FILE}" ]; then
        local last_check=$(cat "${LAST_UPDATE_CHECK_FILE}" 2>/dev/null || echo "0")
        local now=$(date +%s)
        local diff=$((now - last_check))
        if [ $diff -lt $UPDATE_CHECK_INTERVAL ]; then
            return 0
        fi
    fi

    # Record this check time
    date +%s > "${LAST_UPDATE_CHECK_FILE}"

    # Try to fetch remote script (with timeout, silently)
    local remote_script
    remote_script=$(curl -fsSL --connect-timeout 3 --max-time 5 "${SCRIPT_URL}" 2>/dev/null) || return 0

    if [ -z "$remote_script" ]; then
        return 0
    fi

    # Compare using hash
    local local_hash=$(get_local_hash)
    local remote_hash
    if command -v md5 &>/dev/null; then
        remote_hash=$(echo "$remote_script" | md5 -q 2>/dev/null || echo "")
    else
        remote_hash=$(echo "$remote_script" | md5sum 2>/dev/null | cut -d' ' -f1 || echo "")
    fi

    if [ -z "$local_hash" ] || [ -z "$remote_hash" ]; then
        return 0
    fi

    # If hashes differ, update
    if [ "$remote_hash" != "$local_hash" ]; then
        # Extract remote version for display
        local remote_version
        remote_version=$(echo "$remote_script" | grep -m1 '^VERSION=' | cut -d'"' -f2) || remote_version="unknown"

        echo -e "${YELLOW}New version available: ${remote_version} (current: ${VERSION})${NC}"
        echo -e "${BLUE}Updating code-box...${NC}"

        # Find where the script is installed
        local script_path=$(which code-box 2>/dev/null || echo "")
        if [ -z "$script_path" ]; then
            script_path="${HOME}/.local/bin/code-box"
        fi

        # Download and replace
        local tmp_file=$(mktemp)
        if echo "$remote_script" > "$tmp_file" && [ -s "$tmp_file" ]; then
            # Check if we need sudo
            if [ -w "$script_path" ] || [ -w "$(dirname "$script_path")" ]; then
                mv "$tmp_file" "$script_path"
                chmod +x "$script_path"
            else
                sudo mv "$tmp_file" "$script_path"
                sudo chmod +x "$script_path"
            fi
            echo -e "${GREEN}✓ Updated to version ${remote_version}${NC}"
            echo -e "${CYAN}Restarting with new version...${NC}"
            echo ""
            exec "$script_path" "$@"
        else
            rm -f "$tmp_file"
            echo -e "${RED}Update failed, continuing with current version${NC}"
        fi
    fi
}

# Run update check
check_for_updates "$@"

# Initialize ports file if not exists
if [ ! -f "${PORTS_FILE}" ]; then
    echo '{}' > "${PORTS_FILE}"
fi

# Get project identifier (based on current directory)
get_project_id() {
    local dir_path=$(pwd)
    # Create a unique but readable project ID
    echo "${dir_path}" | sed 's|/|_|g' | sed 's|^_||'
}

# Get container name for current project
get_container_name() {
    local project_id=$(get_project_id)
    echo "code_box_$(basename "$(pwd)")"
}

# Check if port is available
is_port_available() {
    local port=$1
    ! lsof -i :${port} >/dev/null 2>&1
}

# Generate random available port
get_random_port() {
    local port
    local attempts=0
    while [ $attempts -lt 100 ]; do
        port=$((RANDOM % (PORT_MAX - PORT_MIN + 1) + PORT_MIN))
        if is_port_available $port; then
            echo $port
            return 0
        fi
        attempts=$((attempts + 1))
    done
    echo "Error: Could not find available port" >&2
    return 1
}

# Read port from config for project
get_saved_port() {
    local project_id=$1
    local port_type=$2  # vnc or novnc
    local port=$(cat "${PORTS_FILE}" | python3 -c "
import sys, json
data = json.load(sys.stdin)
project = data.get('$project_id', {})
print(project.get('$port_type', ''))
" 2>/dev/null)
    echo "$port"
}

# Save port to config
save_ports() {
    local project_id=$1
    local vnc_port=$2
    local novnc_port=$3

    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
data['$project_id'] = {
    'vnc': $vnc_port,
    'novnc': $novnc_port,
    'path': '$(pwd)',
    'container': '$(get_container_name)'
}
with open('${PORTS_FILE}', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Remove project from config
remove_project_ports() {
    local project_id=$1
    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
if '$project_id' in data:
    del data['$project_id']
with open('${PORTS_FILE}', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Get or allocate ports for project
get_ports() {
    local project_id=$(get_project_id)

    # Try to get saved ports
    local saved_vnc=$(get_saved_port "$project_id" "vnc")
    local saved_novnc=$(get_saved_port "$project_id" "novnc")

    # If saved ports exist and are available, use them
    if [ -n "$saved_vnc" ] && [ -n "$saved_novnc" ]; then
        if is_port_available $saved_vnc && is_port_available $saved_novnc; then
            echo "$saved_vnc $saved_novnc"
            return 0
        fi
        # Ports are in use (probably by our container), return saved ports
        echo "$saved_vnc $saved_novnc"
        return 0
    fi

    # Allocate new random ports
    local vnc_port=$(get_random_port)
    local novnc_port=$(get_random_port)

    # Make sure ports are different
    while [ "$novnc_port" == "$vnc_port" ]; do
        novnc_port=$(get_random_port)
    done

    # Save ports
    save_ports "$project_id" "$vnc_port" "$novnc_port"

    echo "$vnc_port $novnc_port"
}

# List all projects and their ports
list_projects() {
    echo -e "${CYAN}Code Box Projects:${NC}"
    echo ""
    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
if not data:
    print('  No projects registered yet.')
else:
    for project_id, info in data.items():
        print(f\"  \033[1m{info.get('container', 'unknown')}\033[0m\")
        print(f\"    Path:   {info.get('path', 'unknown')}\")
        print(f\"    VNC:    localhost:{info.get('vnc', '?')}\")
        print(f\"    noVNC:  http://localhost:{info.get('novnc', '?')}\")
        print()
"
}

# Show help
show_help() {
    echo -e "${GREEN}Code Box - Universal AI Coding Sandbox${NC}"
    echo -e "${CYAN}Version: ${VERSION}${NC}"
    echo ""
    echo "Usage: code-box [COMMAND]"
    echo ""
    echo "Commands:"
    echo "  (no args)    Start or attach to container for current directory"
    echo "  --stop       Stop the container"
    echo "  --remove     Stop and remove the container"
    echo "  --logs       Show container logs"
    echo "  --list       List all projects and their ports"
    echo "  --clean      Remove all stopped containers and clear port registry"
    echo "  --pull       Pull latest Docker image"
    echo "  --update     Check and install updates for code-box CLI"
    echo "  --version    Show version information"
    echo "  --help       Show this help message"
    echo ""
    echo -e "${YELLOW}Installed Tools:${NC}"
    echo "  Claude Code, Codex, Gemini CLI, OpenCode, oh-my-opencode"
    echo ""
    echo -e "${YELLOW}Config Directory:${NC} ${CONFIG_DIR}"
    echo -e "${YELLOW}Ports Registry:${NC}   ${PORTS_FILE}"
}

# Force update check
force_update() {
    echo -e "${BLUE}Checking for updates...${NC}"

    # Remove last check file to force check
    rm -f "${LAST_UPDATE_CHECK_FILE}"

    # Fetch remote script
    local remote_script
    remote_script=$(curl -fsSL --connect-timeout 5 --max-time 10 "${SCRIPT_URL}" 2>/dev/null)

    if [ -z "$remote_script" ]; then
        echo -e "${RED}Failed to check for updates. Please check your internet connection.${NC}"
        exit 1
    fi

    # Extract remote version
    local remote_version
    remote_version=$(echo "$remote_script" | grep -m1 '^VERSION=' | cut -d'"' -f2) || remote_version="unknown"

    # Compare using hash
    local local_hash=$(get_local_hash)
    local remote_hash
    if command -v md5 &>/dev/null; then
        remote_hash=$(echo "$remote_script" | md5 -q 2>/dev/null || echo "")
    else
        remote_hash=$(echo "$remote_script" | md5sum 2>/dev/null | cut -d' ' -f1 || echo "")
    fi

    echo -e "Current version: ${VERSION}"
    echo -e "Latest version:  ${remote_version}"
    echo ""

    if [ "$remote_hash" = "$local_hash" ]; then
        echo -e "${GREEN}You are already running the latest version.${NC}"
        exit 0
    fi

    echo -e "${YELLOW}New version available!${NC}"
    echo -e "${BLUE}Updating code-box...${NC}"

    # Find where the script is installed
    local script_path=$(which code-box 2>/dev/null || echo "")
    if [ -z "$script_path" ]; then
        script_path="${HOME}/.local/bin/code-box"
    fi

    # Download and replace
    local tmp_file=$(mktemp)
    if echo "$remote_script" > "$tmp_file" && [ -s "$tmp_file" ]; then
        # Check if we need sudo
        if [ -w "$script_path" ] || [ -w "$(dirname "$script_path")" ]; then
            mv "$tmp_file" "$script_path"
            chmod +x "$script_path"
        else
            sudo mv "$tmp_file" "$script_path"
            sudo chmod +x "$script_path"
        fi
        echo -e "${GREEN}✓ Successfully updated to version ${remote_version}${NC}"
    else
        rm -f "$tmp_file"
        echo -e "${RED}Update failed.${NC}"
        exit 1
    fi
}

# Pull latest image
pull_image() {
    echo -e "${BLUE}Pulling latest image...${NC}"
    docker pull "${IMAGE_NAME}"
    echo -e "${GREEN}Done!${NC}"
}

# Clean up stopped containers
clean_all() {
    echo -e "${BLUE}Cleaning up stopped code-box containers...${NC}"

    # Find and remove stopped code_box containers
    local containers=$(docker ps -a --filter "name=code_box_" --filter "status=exited" -q)
    if [ -n "$containers" ]; then
        docker rm $containers
        echo -e "${GREEN}Removed stopped containers${NC}"
    else
        echo "No stopped containers to remove"
    fi

    # Clear ports registry
    echo '{}' > "${PORTS_FILE}"
    echo -e "${GREEN}Cleared ports registry${NC}"
}

# Main container operations
CONTAINER_NAME=$(get_container_name)
PROJECT_ID=$(get_project_id)

case "${1:-}" in
    --help|-h)
        show_help
        exit 0
        ;;
    --version|-v)
        echo -e "${GREEN}Code Box${NC} version ${CYAN}${VERSION}${NC}"
        exit 0
        ;;
    --update)
        force_update
        exit 0
        ;;
    --list|-l)
        list_projects
        exit 0
        ;;
    --pull)
        pull_image
        exit 0
        ;;
    --clean)
        clean_all
        exit 0
        ;;
    --stop)
        echo -e "${BLUE}Stopping container: ${CONTAINER_NAME}${NC}"
        docker stop "${CONTAINER_NAME}" 2>/dev/null || echo "Container not running"
        exit 0
        ;;
    --remove)
        echo -e "${BLUE}Removing container: ${CONTAINER_NAME}${NC}"
        docker stop "${CONTAINER_NAME}" 2>/dev/null || true
        docker rm "${CONTAINER_NAME}" 2>/dev/null || echo "Container not found"
        remove_project_ports "$PROJECT_ID"
        echo -e "${GREEN}Done!${NC}"
        exit 0
        ;;
    --logs)
        echo -e "${BLUE}Showing logs for: ${CONTAINER_NAME}${NC}"
        docker logs -f "${CONTAINER_NAME}"
        exit 0
        ;;
esac

# Get ports for this project
read VNC_PORT NOVNC_PORT <<< $(get_ports)

# Check if container already exists
if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${GREEN}Container ${CONTAINER_NAME} is already running.${NC}"
        echo -e "${YELLOW}noVNC:${NC} http://localhost:${NOVNC_PORT}"
        echo -e "${YELLOW}VNC:${NC}   localhost:${VNC_PORT}"
        echo ""
        echo -e "${BLUE}Attaching to container...${NC}"
        docker exec -it "${CONTAINER_NAME}" /bin/bash
    else
        echo -e "${YELLOW}Container ${CONTAINER_NAME} exists but is stopped.${NC}"
        echo -e "${BLUE}Starting container...${NC}"
        docker start "${CONTAINER_NAME}"
        echo -e "${YELLOW}noVNC:${NC} http://localhost:${NOVNC_PORT}"
        echo -e "${YELLOW}VNC:${NC}   localhost:${VNC_PORT}"
        echo ""
        docker exec -it "${CONTAINER_NAME}" /bin/bash
    fi
else
    # Create Claude config directory if it doesn't exist
    mkdir -p "${CLAUDE_CONFIG_DIR}"

    echo -e "${GREEN}Creating new container: ${CONTAINER_NAME}${NC}"
    echo -e "${BLUE}Workspace: $(pwd)${NC}"
    echo -e "${BLUE}VNC Port:  ${VNC_PORT}${NC}"
    echo -e "${BLUE}noVNC Port: ${NOVNC_PORT}${NC}"
    echo ""

    docker run -it \
        --name "${CONTAINER_NAME}" \
        --memory="${MEMORY_LIMIT}" \
        --cpus="${CPU_LIMIT}" \
        --shm-size="${SHM_SIZE}" \
        -v "$(pwd):/home/developer/workspace" \
        -v "${CLAUDE_CONFIG_DIR}:/home/developer/.claude" \
        -p "${VNC_PORT}:5900" \
        -p "${NOVNC_PORT}:6080" \
        -e DISPLAY=:99 \
        "${IMAGE_NAME}" \
        /bin/bash
fi
