#!/bin/bash

# Code Box - Universal AI Coding Sandbox
# https://github.com/nezhazheng/code-box

set -e

# Version - auto-generated from last modified date
# Format: YYYY.MM.DD (updated automatically when script changes)
VERSION="2026.01.18"

# Color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configuration
IMAGE_NAME="nezhazheng/code-box:latest"
CONFIG_DIR="${HOME}/.code-box"
PORTS_FILE="${CONFIG_DIR}/ports.json"
CLAUDE_CONFIG_DIR="${HOME}/.claude_config_docker"
CODEX_CONFIG_DIR="${HOME}/.codex_config_docker"
LAST_UPDATE_CHECK_FILE="${CONFIG_DIR}/.last_update_check"
UPDATE_CHECK_INTERVAL=86400  # 24 hours in seconds

# Update URLs
REPO_RAW_URL="https://raw.githubusercontent.com/nezhazheng/code-box/main"
SCRIPT_URL="${REPO_RAW_URL}/code-box"

# Resource limits
MEMORY_LIMIT="4g"
CPU_LIMIT="2"
SHM_SIZE="2g"

# Port range for random allocation
PORT_MIN=10000
PORT_MAX=60000

# Supported tools list
TOOLS=("claude" "codex" "gemini" "opencode" "omo" "bash")

# Get tool display name
get_tool_name() {
    case "$1" in
        claude)   echo "Claude Code (Anthropic)" ;;
        codex)    echo "Codex (OpenAI)" ;;
        gemini)   echo "Gemini CLI (Google)" ;;
        opencode) echo "OpenCode" ;;
        omo)      echo "oh-my-opencode" ;;
        bash)     echo "Bash Shell (无特定工具)" ;;
        *)        echo "$1" ;;
    esac
}

# Get tool YOLO mode flag
get_tool_yolo_flag() {
    case "$1" in
        claude)   echo "--dangerously-skip-permissions" ;;
        codex)    echo "--full-auto" ;;
        gemini)   echo "--yolo" ;;
        opencode) echo "--dangerously-skip-permissions" ;;
        omo)      echo "--dangerously-skip-permissions" ;;
        bash)     echo "" ;;
        *)        echo "" ;;
    esac
}

# Ensure config directory exists
mkdir -p "${CONFIG_DIR}"

# Get hash of current script
get_local_hash() {
    local script_path=$(which code-box 2>/dev/null || echo "${HOME}/.local/bin/code-box")
    if [ -f "$script_path" ]; then
        # Use md5 on macOS, md5sum on Linux
        if command -v md5 &>/dev/null; then
            md5 -q "$script_path" 2>/dev/null || echo ""
        else
            md5sum "$script_path" 2>/dev/null | cut -d' ' -f1 || echo ""
        fi
    fi
}

# Auto-update check function
check_for_updates() {
    # Skip update check for certain commands
    case "${1:-}" in
        --help|-h|--version|-v|--update)
            return 0
            ;;
    esac

    # Check if we should skip update check (based on last check time)
    if [ -f "${LAST_UPDATE_CHECK_FILE}" ]; then
        local last_check=$(cat "${LAST_UPDATE_CHECK_FILE}" 2>/dev/null || echo "0")
        local now=$(date +%s)
        local diff=$((now - last_check))
        if [ $diff -lt $UPDATE_CHECK_INTERVAL ]; then
            return 0
        fi
    fi

    # Record this check time
    date +%s > "${LAST_UPDATE_CHECK_FILE}"

    # Try to fetch remote script (with timeout, silently)
    local remote_script
    remote_script=$(curl -fsSL --connect-timeout 3 --max-time 5 "${SCRIPT_URL}" 2>/dev/null) || return 0

    if [ -z "$remote_script" ]; then
        return 0
    fi

    # Compare using hash
    local local_hash=$(get_local_hash)
    local remote_hash
    if command -v md5 &>/dev/null; then
        remote_hash=$(echo "$remote_script" | md5 -q 2>/dev/null || echo "")
    else
        remote_hash=$(echo "$remote_script" | md5sum 2>/dev/null | cut -d' ' -f1 || echo "")
    fi

    if [ -z "$local_hash" ] || [ -z "$remote_hash" ]; then
        return 0
    fi

    # If hashes differ, prompt for update
    if [ "$remote_hash" != "$local_hash" ]; then
        # Extract remote version for display
        local remote_version
        remote_version=$(echo "$remote_script" | grep -m1 '^VERSION=' | cut -d'"' -f2) || remote_version="unknown"

        echo ""
        echo -e "${YELLOW}[Code Box] A new version is available: ${remote_version} (current: ${VERSION})${NC}"
        echo -n -e "${CYAN}Would you like to update? [Y/n] ${NC}"

        # Read user input with timeout
        local answer
        read -t 10 -n 1 answer 2>/dev/null || answer="n"
        echo ""  # New line after input

        # Default to yes if empty or 'y'
        if [[ "$answer" =~ ^[Yy]$ ]] || [[ -z "$answer" ]]; then
            echo -e "${BLUE}Updating code-box CLI...${NC}"

            # Find where the script is installed
            local script_path=$(which code-box 2>/dev/null || echo "")
            if [ -z "$script_path" ]; then
                script_path="${HOME}/.local/bin/code-box"
            fi

            # Download and replace
            local tmp_file=$(mktemp)
            if echo "$remote_script" > "$tmp_file" && [ -s "$tmp_file" ]; then
                # Check if we need sudo
                if [ -w "$script_path" ] || [ -w "$(dirname "$script_path")" ]; then
                    mv "$tmp_file" "$script_path"
                    chmod +x "$script_path"
                else
                    sudo mv "$tmp_file" "$script_path"
                    sudo chmod +x "$script_path"
                fi
                echo -e "${GREEN}✓ CLI updated to version ${remote_version}${NC}"

                # Also pull latest Docker image
                echo -e "${BLUE}Pulling latest Docker image...${NC}"
                docker pull "${IMAGE_NAME}" 2>/dev/null && echo -e "${GREEN}✓ Docker image updated${NC}" || echo -e "${YELLOW}⚠ Docker image pull failed${NC}"

                echo -e "${CYAN}Restarting with new version...${NC}"
                echo ""
                exec "$script_path" "$@"
            else
                rm -f "$tmp_file"
                echo -e "${RED}Update failed, continuing with current version${NC}"
            fi
        else
            echo -e "${CYAN}Update skipped. Run 'code-box --update' to update manually.${NC}"
            echo ""
        fi
    fi
}

# Run update check
check_for_updates "$@"

# Initialize ports file if not exists
if [ ! -f "${PORTS_FILE}" ]; then
    echo '{}' > "${PORTS_FILE}"
fi

# Get project identifier (based on current directory)
get_project_id() {
    local dir_path=$(pwd)
    # Create a unique but readable project ID
    echo "${dir_path}" | sed 's|/|_|g' | sed 's|^_||'
}

# Get container name for current project
get_container_name() {
    local project_id=$(get_project_id)
    echo "code_box_$(basename "$(pwd)")"
}

# Check if port is available
is_port_available() {
    local port=$1
    ! lsof -i :${port} >/dev/null 2>&1
}

# Generate random available port
get_random_port() {
    local port
    local attempts=0
    while [ $attempts -lt 100 ]; do
        port=$((RANDOM % (PORT_MAX - PORT_MIN + 1) + PORT_MIN))
        if is_port_available $port; then
            echo $port
            return 0
        fi
        attempts=$((attempts + 1))
    done
    echo "Error: Could not find available port" >&2
    return 1
}

# Read port from config for project
get_saved_port() {
    local project_id=$1
    local port_type=$2  # vnc or novnc
    local port=$(cat "${PORTS_FILE}" | python3 -c "
import sys, json
data = json.load(sys.stdin)
project = data.get('$project_id', {})
print(project.get('$port_type', ''))
" 2>/dev/null)
    echo "$port"
}

# Save port to config
save_ports() {
    local project_id=$1
    local vnc_port=$2
    local novnc_port=$3

    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
data['$project_id'] = {
    'vnc': $vnc_port,
    'novnc': $novnc_port,
    'path': '$(pwd)',
    'container': '$(get_container_name)'
}
with open('${PORTS_FILE}', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Remove project from config
remove_project_ports() {
    local project_id=$1
    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
if '$project_id' in data:
    del data['$project_id']
with open('${PORTS_FILE}', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Get or allocate ports for project
get_ports() {
    local project_id=$(get_project_id)

    # Try to get saved ports
    local saved_vnc=$(get_saved_port "$project_id" "vnc")
    local saved_novnc=$(get_saved_port "$project_id" "novnc")

    # If saved ports exist and are available, use them
    if [ -n "$saved_vnc" ] && [ -n "$saved_novnc" ]; then
        if is_port_available $saved_vnc && is_port_available $saved_novnc; then
            echo "$saved_vnc $saved_novnc"
            return 0
        fi
        # Ports are in use (probably by our container), return saved ports
        echo "$saved_vnc $saved_novnc"
        return 0
    fi

    # Allocate new random ports
    local vnc_port=$(get_random_port)
    local novnc_port=$(get_random_port)

    # Make sure ports are different
    while [ "$novnc_port" == "$vnc_port" ]; do
        novnc_port=$(get_random_port)
    done

    # Save ports
    save_ports "$project_id" "$vnc_port" "$novnc_port"

    echo "$vnc_port $novnc_port"
}

# List all projects and their ports
list_projects() {
    echo -e "${CYAN}Code Box Projects:${NC}"
    echo ""
    python3 -c "
import json
with open('${PORTS_FILE}', 'r') as f:
    data = json.load(f)
if not data:
    print('  No projects registered yet.')
else:
    for project_id, info in data.items():
        print(f\"  \033[1m{info.get('container', 'unknown')}\033[0m\")
        print(f\"    Path:   {info.get('path', 'unknown')}\")
        print(f\"    VNC:    localhost:{info.get('vnc', '?')}\")
        print(f\"    noVNC:  http://localhost:{info.get('novnc', '?')}/vnc.html\")
        print()
"
}

# Show help
show_help() {
    echo -e "${GREEN}Code Box - Universal AI Coding Sandbox${NC}"
    echo -e "${CYAN}Version: ${VERSION}${NC}"
    echo ""
    echo "Usage: code-box [TOOL|COMMAND]"
    echo ""
    echo -e "${YELLOW}Tools (start with YOLO mode):${NC}"
    echo "  claude       Launch Claude Code (--dangerously-skip-permissions)"
    echo "  codex        Launch Codex (--full-auto)"
    echo "  gemini       Launch Gemini CLI (--yolo)"
    echo "  opencode     Launch OpenCode"
    echo "  omo          Launch oh-my-opencode"
    echo "  bash         Launch Bash shell only"
    echo ""
    echo -e "${YELLOW}Commands:${NC}"
    echo "  (no args)    Show tool selection menu"
    echo "  --stop       Stop the container"
    echo "  --remove     Stop and remove the container"
    echo "  --logs       Show container logs"
    echo "  --list       List all projects and their ports"
    echo "  --clean      Remove all stopped containers and clear port registry"
    echo "  --pull       Pull latest Docker image"
    echo "  --update     Update CLI and pull latest Docker image"
    echo "  --version    Show version information"
    echo "  --help       Show this help message"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  code-box              # Show interactive tool selection"
    echo "  code-box claude       # Start Claude Code in YOLO mode"
    echo "  code-box codex        # Start Codex in full-auto mode"
    echo ""
    echo -e "${YELLOW}Config Directory:${NC} ${CONFIG_DIR}"
    echo -e "${YELLOW}Ports Registry:${NC}   ${PORTS_FILE}"
}

# Force update check (updates both CLI and Docker image)
force_update() {
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}  Code Box Update${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""

    # Remove last check file to force check
    rm -f "${LAST_UPDATE_CHECK_FILE}"

    # Step 1: Update CLI
    echo -e "${CYAN}[1/2] Checking for CLI updates...${NC}"
    local remote_script
    remote_script=$(curl -fsSL --connect-timeout 5 --max-time 10 "${SCRIPT_URL}" 2>/dev/null)

    if [ -z "$remote_script" ]; then
        echo -e "${RED}Failed to check for updates. Please check your internet connection.${NC}"
        exit 1
    fi

    # Extract remote version
    local remote_version
    remote_version=$(echo "$remote_script" | grep -m1 '^VERSION=' | cut -d'"' -f2) || remote_version="unknown"

    # Compare using hash
    local local_hash=$(get_local_hash)
    local remote_hash
    if command -v md5 &>/dev/null; then
        remote_hash=$(echo "$remote_script" | md5 -q 2>/dev/null || echo "")
    else
        remote_hash=$(echo "$remote_script" | md5sum 2>/dev/null | cut -d' ' -f1 || echo "")
    fi

    echo -e "Current CLI version: ${VERSION}"
    echo -e "Latest CLI version:  ${remote_version}"

    if [ "$remote_hash" != "$local_hash" ]; then
        echo -e "${YELLOW}New CLI version available!${NC}"
        echo -e "${BLUE}Updating CLI...${NC}"

        # Find where the script is installed
        local script_path=$(which code-box 2>/dev/null || echo "")
        if [ -z "$script_path" ]; then
            script_path="${HOME}/.local/bin/code-box"
        fi

        # Download and replace
        local tmp_file=$(mktemp)
        if echo "$remote_script" > "$tmp_file" && [ -s "$tmp_file" ]; then
            # Check if we need sudo
            if [ -w "$script_path" ] || [ -w "$(dirname "$script_path")" ]; then
                mv "$tmp_file" "$script_path"
                chmod +x "$script_path"
            else
                sudo mv "$tmp_file" "$script_path"
                sudo chmod +x "$script_path"
            fi
            echo -e "${GREEN}✓ CLI updated to ${remote_version}${NC}"
        else
            rm -f "$tmp_file"
            echo -e "${RED}CLI update failed.${NC}"
            exit 1
        fi
    else
        echo -e "${GREEN}✓ CLI is already up to date${NC}"
    fi
    echo ""

    # Step 2: Update Docker image
    echo -e "${CYAN}[2/2] Pulling latest Docker image...${NC}"
    docker pull "${IMAGE_NAME}"
    echo -e "${GREEN}✓ Docker image updated${NC}"
    echo ""

    # Check if there's a container in current directory that needs restart
    local container_name=$(get_container_name)
    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        echo -e "${YELLOW}Note: Container '${container_name}' is using the old image.${NC}"
        echo -e "${CYAN}To use the new image, restart the container:${NC}"
        echo -e "  ${CYAN}code-box --remove${NC}"
        echo -e "  ${CYAN}code-box${NC}"
    fi

    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}  Update Complete!${NC}"
    echo -e "${GREEN}========================================${NC}"
}

# Pull latest image
pull_image() {
    echo -e "${BLUE}Pulling latest image...${NC}"
    docker pull "${IMAGE_NAME}"
    echo -e "${GREEN}Done!${NC}"
}

# Clean up stopped containers
clean_all() {
    echo -e "${BLUE}Cleaning up stopped code-box containers...${NC}"

    # Find and remove stopped code_box containers
    local containers=$(docker ps -a --filter "name=code_box_" --filter "status=exited" -q)
    if [ -n "$containers" ]; then
        docker rm $containers
        echo -e "${GREEN}Removed stopped containers${NC}"
    else
        echo "No stopped containers to remove"
    fi

    # Clear ports registry
    echo '{}' > "${PORTS_FILE}"
    echo -e "${GREEN}Cleared ports registry${NC}"
}

# Check if argument is a valid tool name
is_valid_tool() {
    local tool=$1
    for t in "${TOOLS[@]}"; do
        if [ "$t" == "$tool" ]; then
            return 0
        fi
    done
    return 1
}

# Interactive tool selection menu with arrow keys
select_tool() {
    local selected=0
    local total=${#TOOLS[@]}

    # Hide cursor
    tput civis 2>/dev/null || true

    # Function to draw the menu
    draw_menu() {
        # Move cursor to start position and clear
        echo -e "\033[${total}A" 2>/dev/null || true

        local i=0
        for tool in "${TOOLS[@]}"; do
            local tool_display=$(get_tool_name "$tool")
            local yolo_flag=$(get_tool_yolo_flag "$tool")

            if [ $i -eq $selected ]; then
                # Highlighted item
                if [ "$tool" == "bash" ]; then
                    echo -e "  ${CYAN}▶${NC} ${GREEN}${tool_display}${NC}"
                else
                    echo -e "  ${CYAN}▶${NC} ${GREEN}${tool_display}${NC} ${YELLOW}${yolo_flag}${NC}"
                fi
            else
                # Normal item
                if [ "$tool" == "bash" ]; then
                    echo -e "    ${tool_display}"
                else
                    echo -e "    ${tool_display}"
                fi
            fi
            i=$((i + 1))
        done
    }

    # Print header
    echo ""
    echo -e "${CYAN}╔════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║      选择要启动的 Vibe Coding 工具      ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${YELLOW}  ↑/↓ 选择  Enter 确认  q 退出${NC}"
    echo ""

    # Initial draw
    local i=0
    for tool in "${TOOLS[@]}"; do
        local tool_display=$(get_tool_name "$tool")
        local yolo_flag=$(get_tool_yolo_flag "$tool")

        if [ $i -eq $selected ]; then
            if [ "$tool" == "bash" ]; then
                echo -e "  ${CYAN}▶${NC} ${GREEN}${tool_display}${NC}"
            else
                echo -e "  ${CYAN}▶${NC} ${GREEN}${tool_display}${NC} ${YELLOW}${yolo_flag}${NC}"
            fi
        else
            if [ "$tool" == "bash" ]; then
                echo -e "    ${tool_display}"
            else
                echo -e "    ${tool_display}"
            fi
        fi
        i=$((i + 1))
    done

    # Read keys
    while true; do
        # Read single character
        IFS= read -rsn1 key

        # Check for escape sequence (arrow keys)
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 -t 0.1 key
            case "$key" in
                '[A') # Up arrow
                    selected=$((selected - 1))
                    if [ $selected -lt 0 ]; then
                        selected=$((total - 1))
                    fi
                    ;;
                '[B') # Down arrow
                    selected=$((selected + 1))
                    if [ $selected -ge $total ]; then
                        selected=0
                    fi
                    ;;
            esac
            draw_menu
        elif [[ $key == '' ]]; then
            # Enter key
            break
        elif [[ $key == 'q' ]] || [[ $key == 'Q' ]]; then
            # Quit
            tput cnorm 2>/dev/null || true
            echo ""
            echo -e "${YELLOW}已取消${NC}"
            exit 0
        elif [[ $key == 'j' ]]; then
            # vim-style down
            selected=$((selected + 1))
            if [ $selected -ge $total ]; then
                selected=0
            fi
            draw_menu
        elif [[ $key == 'k' ]]; then
            # vim-style up
            selected=$((selected - 1))
            if [ $selected -lt 0 ]; then
                selected=$((total - 1))
            fi
            draw_menu
        fi
    done

    # Show cursor
    tput cnorm 2>/dev/null || true

    SELECTED_TOOL="${TOOLS[$selected]}"
    echo ""
}

# Run selected tool in container
run_tool_in_container() {
    local container_name=$1
    local tool=$2

    if [ "$tool" == "bash" ] || [ -z "$tool" ]; then
        docker exec -it -w /home/developer/workspace "${container_name}" /bin/bash
    else
        local yolo_flag=$(get_tool_yolo_flag "$tool")
        local tool_display=$(get_tool_name "$tool")
        echo ""
        echo -e "${GREEN}启动 ${tool_display}...${NC}"
        if [ -n "$yolo_flag" ]; then
            echo -e "${YELLOW}⚠ YOLO 模式已启用 (${yolo_flag})${NC}"
        fi
        echo ""
        docker exec -it -w /home/developer/workspace "${container_name}" /bin/bash -c "${tool} ${yolo_flag}; exec bash"
    fi
}

# Main container operations
CONTAINER_NAME=$(get_container_name)
PROJECT_ID=$(get_project_id)

case "${1:-}" in
    --help|-h)
        show_help
        exit 0
        ;;
    --version|-v)
        echo -e "${GREEN}Code Box${NC} version ${CYAN}${VERSION}${NC}"
        exit 0
        ;;
    --update)
        force_update
        exit 0
        ;;
    --list|-l)
        list_projects
        exit 0
        ;;
    --pull)
        pull_image
        exit 0
        ;;
    --clean)
        clean_all
        exit 0
        ;;
    --stop)
        echo -e "${BLUE}Stopping container: ${CONTAINER_NAME}${NC}"
        docker stop "${CONTAINER_NAME}" 2>/dev/null || echo "Container not running"
        exit 0
        ;;
    --remove)
        echo -e "${BLUE}Removing container: ${CONTAINER_NAME}${NC}"
        docker stop "${CONTAINER_NAME}" 2>/dev/null || true
        docker rm "${CONTAINER_NAME}" 2>/dev/null || echo "Container not found"
        remove_project_ports "$PROJECT_ID"
        echo -e "${GREEN}Done!${NC}"
        exit 0
        ;;
    --logs)
        echo -e "${BLUE}Showing logs for: ${CONTAINER_NAME}${NC}"
        docker logs -f "${CONTAINER_NAME}"
        exit 0
        ;;
esac

# Handle tool argument or show selection menu
SELECTED_TOOL=""
if [ -n "${1:-}" ]; then
    # Check if argument is a valid tool name
    if is_valid_tool "$1"; then
        SELECTED_TOOL="$1"
    else
        echo -e "${RED}Unknown tool or command: $1${NC}"
        echo "Use 'code-box --help' to see available tools and commands."
        exit 1
    fi
else
    # No argument provided, show interactive selection menu
    select_tool
fi

# Get ports for this project
read VNC_PORT NOVNC_PORT <<< $(get_ports)

# Check if container already exists
if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${GREEN}Container ${CONTAINER_NAME} is already running.${NC}"
        echo -e "${YELLOW}noVNC:${NC} http://localhost:${NOVNC_PORT}/vnc.html"
        echo -e "${YELLOW}VNC:${NC}   localhost:${VNC_PORT}"
        echo ""
        echo -e "${BLUE}Attaching to container...${NC}"
        run_tool_in_container "${CONTAINER_NAME}" "${SELECTED_TOOL}"
    else
        echo -e "${YELLOW}Container ${CONTAINER_NAME} exists but is stopped.${NC}"
        echo -e "${BLUE}Starting container...${NC}"
        docker start "${CONTAINER_NAME}"
        echo -e "${YELLOW}noVNC:${NC} http://localhost:${NOVNC_PORT}/vnc.html"
        echo -e "${YELLOW}VNC:${NC}   localhost:${VNC_PORT}"
        echo ""
        run_tool_in_container "${CONTAINER_NAME}" "${SELECTED_TOOL}"
    fi
else
    # Create config directories if they don't exist
    mkdir -p "${CLAUDE_CONFIG_DIR}"
    mkdir -p "${CODEX_CONFIG_DIR}"

    echo -e "${GREEN}Creating new container: ${CONTAINER_NAME}${NC}"
    echo -e "${BLUE}Workspace: $(pwd)${NC}"
    echo -e "${BLUE}VNC Port:  ${VNC_PORT}${NC}"
    echo -e "${BLUE}noVNC Port: ${NOVNC_PORT}${NC}"
    echo ""

    # Start container in background first (to let entrypoint start VNC services)
    docker run -d \
        --name "${CONTAINER_NAME}" \
        --memory="${MEMORY_LIMIT}" \
        --cpus="${CPU_LIMIT}" \
        --shm-size="${SHM_SIZE}" \
        -v "$(pwd):/home/developer/workspace" \
        -v "${CLAUDE_CONFIG_DIR}:/home/developer/.claude" \
        -v "${CODEX_CONFIG_DIR}:/home/developer/.codex" \
        -p "${VNC_PORT}:5900" \
        -p "${NOVNC_PORT}:6080" \
        -e DISPLAY=:99 \
        "${IMAGE_NAME}" > /dev/null

    # Wait for container to be ready
    echo -e "${BLUE}Waiting for container to start...${NC}"
    sleep 2

    echo -e "${YELLOW}noVNC:${NC} http://localhost:${NOVNC_PORT}/vnc.html"
    echo -e "${YELLOW}VNC:${NC}   localhost:${VNC_PORT}"
    echo ""

    # Run the selected tool
    run_tool_in_container "${CONTAINER_NAME}" "${SELECTED_TOOL}"
fi
